//the primary way me and alex did this that alex input the code and i did the debugging 

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.Ellipse2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;
import java.io.*; 
import javax.imageio.ImageIO; // made it javax
import java.awt.image.BufferedImage;

// added gameover logic: 161,289,375,



public class WarhammerExpanded extends JFrame {
    public WarhammerExpanded() {
        setTitle("Warhammer: Infinite Tides of Battle[ULTIMATE EDITION]");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setResizable(false);
        GamePanel panel = new GamePanel();
        add(panel);
        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    public static void main(String[] args) {
        System.setProperty("sun.java2d.opengl", "true");
        SwingUtilities.invokeLater(WarhammerExpanded::new);
    }
}

class GamePanel extends JPanel implements ActionListener, KeyListener, MouseListener, MouseMotionListener {

    // --- CONFIG ---
    public static final int WIDTH = 1024;
    public static final int HEIGHT = 640;
    private static final int FPS = 60;
    
    //Variables added by Alex for images
    private BufferedImage playerPNG;
    private BufferedImage enemyPNG;
    private BufferedImage elitePNG;
    private BufferedImage bossPNG;

    // --- ENUMS ---
    enum State { MENU, FACTION_SELECT, PLAYING, GAME_OVER }
    enum Faction {
        ULTRAMARINE(new Color(30, 60, 200), "Ultramarine", "Double Dmg"),
        TYRANIDS(new Color(128, 0, 128), "Tyranids", "Melee Only"),
        DEATHWATCH(new Color(100, 100, 100), "Deathwatch", "Toxic Aura"),
        RAVENGUARD(new Color(20, 20, 20), "Ravenguard", "Triple Jump");

        Color color; String name; String desc;
        Faction(Color c, String n, String d) { color = c; name = n; desc = d; }
    }
    enum BuffType { HEAL, DAMAGE, SPEED, FIRE_FLOWER }
    enum EnemyType { GRUNT, ELITE, BOSS }

    // --- GAME STATE ---
    private State currentState = State.MENU;
    private Timer gameTimer;
    private Random rand = new Random();
    private boolean valueOfPower = flase; 

    // --- ENTITIES ---
    private Player player;
    private ArrayList<Platform> platforms = new ArrayList<>();
    private ArrayList<Projectile> projectiles = new ArrayList<>();
    private ArrayList<Enemy> enemies = new ArrayList<>();
    private ArrayList<Buff> buffs = new ArrayList<>();
    private ArrayList<Particle> particles = new ArrayList<>();
    private ArrayList<Star> stars = new ArrayList<>(); // Background visuals

    // --- LOGIC ---
    private Faction selectedFaction = null;
    private long startTime;
    private long lastSpawnTime;
    private long lastEliteSpawn;
    private long lastBossSpawn;
    private int score = 0;
    private int mouseX, mouseY;

    // --- OPTIMIZATION CACHE ---
    private static final Color MIASMA_COLOR = new Color(0, 255, 0, 50);
    private static final Color BACKGROUND_COLOR = new Color(10, 10, 15);
    private static final Color UI_OVERLAY_COLOR = new Color(0,0,0,150);
    private static final Color GAME_OVER_BG = new Color(0,0,0,200);

    // --- INPUT ---
    private boolean left, right;
    private boolean jumpPressed = false; 

    // --- UI ELEMENTS ---
    private Rectangle btnPlay = new Rectangle(WIDTH/2 - 100, 250, 200, 50);
    private Rectangle btnFaction = new Rectangle(WIDTH/2 - 100, 320, 200, 50);
    private Rectangle[] factionBtns = new Rectangle[4];
    private Rectangle btnBack = new Rectangle(WIDTH/2 - 100, 500, 200, 50);

    public GamePanel() {
        loadPNG(); //realized that we have to call the method too
        setPreferredSize(new Dimension(WIDTH, HEIGHT));
        setBackground(Color.BLACK);
        setFocusable(true); 
        addKeyListener(this);
        addMouseListener(this);
        addMouseMotionListener(this);

        // Generate Stars
        for(int i=0; i<100; i++) stars.add(new Star());

        // Setup UI
        int startX = 112;
        for(int i=0; i<4; i++) factionBtns[i] = new Rectangle(startX + (i*210), 250, 200, 150);

        // Map Gen
        generateLevel();

        gameTimer = new Timer(1000/FPS, this);
        gameTimer.start();
    }
    
 
    @Override
    public void addNotify() {
        super.addNotify();
        requestFocusInWindow();
    }

    private void generateLevel() {
        platforms.clear();
        platforms.add(new Platform(0, HEIGHT-40, WIDTH, 40)); // Floor
        platforms.add(new Platform(200, 450, 200, 20));
        platforms.add(new Platform(624, 450, 200, 20));
        platforms.add(new Platform(412, 300, 200, 20)); // Mid High
        platforms.add(new Platform(100, 200, 150, 20)); // Top Left
        platforms.add(new Platform(774, 200, 150, 20)); // Top Right
    }

    private void startGame() {
        player = new Player(WIDTH/2, HEIGHT - 100, selectedFaction);
        enemies.clear();
        projectiles.clear();
        buffs.clear();
        particles.clear();
        score = 0;
        startTime = System.currentTimeMillis();
        lastEliteSpawn = startTime;
        lastBossSpawn = startTime;
        currentState = State.PLAYING;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        updateBackground(); 

        if (currentState == State.PLAYING) {
            updateGame();
        }
        repaint();
    }

    private void updateBackground() {
        for(Star s : stars) s.update();
    }
    
    private void loadPNG(){// Added by Alex + Saket de-bugg 
    try{
        playerPNG = ImageIO.read(new File("image-removebg-preview (4).png"));
        enemyPNG = ImageIO.read(new File("image-removebg-preview (5).png"));
        elitePNG = ImageIO.read(new File("image-removebg-preview (6).png"));
        bossPNG = ImageIO.read(new File("image-removebg-preview (7).png"));
        
    }catch (IOException i){
        i.printStackTrace; 
    }
}
    //i searched it up online and i found our i can use a try catch on this 
    //also learned that file names have to be string 
    //dude im gonna de-bug what you added 
    

    private void updateGame() {
        long now = System.currentTimeMillis();

        //i learned about the fact that updateGame runs about 60 times per second. 
        //so the score will save 60 time PER SECOND FOR EACH FRAME
        //i did about an hour of digging and found out that a easier thing to do is
        //make a boolean that decides whether the score has actually saved once or not
        //from that it will actually make sure the score is saved 
        //im gonna call it valueOfPower so it fits the theme 
        
        if (player.hp <= 0 && !valueOfPower) {// added by Alex + Saket debug 
            currentState = State.GAME_OVER;// changes game state
            codexScrollOfChaos(score);
            valueOfPower = true; //basically saying (from my knowledge): "I probably did save the score right?"
            //does the code and says "yeah no, i was right"
            return;
        }

        // --- SPAWNING ---
        // Normal Grunts (Frequency increases with time)
        int difficulty = (int)((now - startTime) / 10000); // gets harder every 10s
        int spawnRate = Math.max(500, 2000 - (difficulty * 100));

        if (now - lastSpawnTime > spawnRate) {
            spawnEnemy(EnemyType.GRUNT);
            lastSpawnTime = now;
        }

        // Elite (Every 1 min)
        if (now - lastEliteSpawn > 60000) {
            spawnEnemy(EnemyType.ELITE);
            lastEliteSpawn = now;
            addNotification("ELITE ENEMY APPROACHING", Color.ORANGE);
        }

        // Boss (Every 2 mins)
        if (now - lastBossSpawn > 120000) {
            spawnEnemy(EnemyType.BOSS);
            lastBossSpawn = now;
            addNotification("WARNING: HIVE TYRANT DETECTED", Color.RED);
        }

        // --- UPDATES ---
        player.update();

        // Projectiles
        Iterator<Projectile> pit = projectiles.iterator();
        while(pit.hasNext()) {
            Projectile p = pit.next();
            p.update();
            if(p.remove) pit.remove();
        }

        // Enemies
        Iterator<Enemy> eit = enemies.iterator();
        while(eit.hasNext()) {
            Enemy en = eit.next();
            en.update();

            // Deathwatch Miasma Logic
            if(player.faction == Faction.DEATHWATCH) {
                // Optimization: squared distance check is faster
                double distSq = Math.pow(player.x - en.x, 2) + Math.pow(player.y - en.y, 2);
                if(distSq < 10000 && now % 30 == 0) { // 100*100 = 10000
                    en.takeDamage(1);
                    particles.add(new Particle(en.x, en.y, Color.GREEN, 2));
                }
            }

            if(en.dead) {
                // Drop Buff Chance
                if(rand.nextInt(100) < 15) buffs.add(new Buff(en.x, en.y));
                // Score
                score += (en.type == EnemyType.BOSS ? 500 : (en.type == EnemyType.ELITE ? 100 : 10));
                // Explosion
                createExplosion(en.x, en.y, en.width * 2, en.color);
                eit.remove();
            } else if (en.getBounds().intersects(player.getBounds())) {
                // Player hit
                player.takeDamage(1);
                createExplosion(player.x, player.y, 10, Color.RED);
                // Knockback
                if(en.x < player.x) player.velX = 10; else player.velX = -10;
                player.velY = -5;
            }
        }

        // Buffs
        Iterator<Buff> bit = buffs.iterator();
        while(bit.hasNext()) {
            Buff b = bit.next();
            b.update();
            if(player.getBounds().intersects(b.getBounds())) {
                player.applyBuff(b.type);
                bit.remove();
            }
        }

        // Particles
        Iterator<Particle> parIt = particles.iterator();
        while(parIt.hasNext()) {
            Particle p = parIt.next();
            p.update();
            if(p.life <= 0) parIt.remove();
        }
    }

    private void spawnEnemy(EnemyType type) {
        int x = rand.nextBoolean() ? -50 : WIDTH + 50;
        int y = 50; // spawn in air
        enemies.add(new Enemy(x, y, type));
    }

    private void addNotification(String text, Color c) {
        System.out.println(text);
    }

    private void createExplosion(double x, double y, int size, Color c) {
        for(int i=0; i<10; i++) {
            particles.add(new Particle(x, y, c, size/2));
        }
    }


    private double getDist(double x1, double y1, double x2, double y2) {
        return Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    }

    // --- RENDERING ---
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Background
        g2.setColor(BACKGROUND_COLOR);
        g2.fillRect(0, 0, WIDTH, HEIGHT);
        for(Star s : stars) s.draw(g2);

        if(currentState == State.MENU) drawMenu(g2);// Edited by Alex
        else if(currentState == State.FACTION_SELECT) drawFactionSelect(g2);// these are the current states that the game can be in. faction select, Playing or Dead
        else if(currentState == State.PLAYING) drawGame(g2);
        else if(currentState == State.GAME_OVER) drawGameOver(g2);
        
        // Sync display to prevent tearing on some systems
        Toolkit.getDefaultToolkit().sync();
    }

    private void drawMenu(Graphics2D g) {
        drawGlowingText(g, "WARHAMMER ROGUELIKE", 60, WIDTH/2, 150, Color.CYAN);
        drawButton(g, btnPlay, "PLAY", selectedFaction != null);
        drawButton(g, btnFaction, selectedFaction == null ? "SELECT FACTION" : selectedFaction.name, true);

        if(selectedFaction != null) {
            g.setColor(selectedFaction.color);
            g.fillOval(WIDTH/2 - 10, 380, 20, 20);
        }
    }

    private void drawFactionSelect(Graphics2D g) {
        drawGlowingText(g, "SELECT YOUR ALLEGIANCE", 40, WIDTH/2, 100, Color.WHITE);

        for(int i=0; i<Faction.values().length; i++) {
            Faction f = Faction.values()[i];
            Rectangle r = factionBtns[i];

            // Hover effect logic
            boolean selected = (selectedFaction == f);

            g.setColor(selected ? f.color : f.color.darker().darker());
            g.fill(r);
            g.setColor(selected ? Color.WHITE : Color.GRAY);
            g.setStroke(new BasicStroke(selected ? 3 : 1));
            g.draw(r);

            g.setColor(Color.WHITE);
            g.setFont(new Font("Arial", Font.BOLD, 18));
            drawCenteredString(g, f.name, r.x + r.width/2, r.y + 40);
            g.setFont(new Font("Arial", Font.ITALIC, 14));
            drawCenteredString(g, f.desc, r.x + r.width/2, r.y + 70);
        }

        drawButton(g, btnBack, "BACK", true);
    }

    private void drawGame(Graphics2D g) {
        // Platforms
        g.setColor(Color.DARK_GRAY);
        for(Platform p : platforms) {
            g.fill(p);
            g.setColor(Color.GRAY);
            g.drawRect(p.x, p.y, p.width, p.height);
        }

        // Particles (Behind entities)
        for(Particle p : particles) p.draw(g);

        // Buffs
        for(Buff b : buffs) b.draw(g);

        // Enemies
        for(Enemy e : enemies) e.draw(g);

        // Player
        player.draw(g);

        // Projectiles
        for(Projectile p : projectiles) p.draw(g);

        // UI Overlay
        g.setColor(UI_OVERLAY_COLOR);
        g.fillRect(0,0,WIDTH, 40);

        g.setColor(Color.WHITE);
        g.setFont(new Font("Consolas", Font.BOLD, 20));
        g.drawString("HP: " + player.hp + "/" + player.maxHp, 20, 27);
        g.drawString("SCORE: " + score, 200, 27);

        // Fire Flower Indicator
        if(player.hasFireFlower) {
            g.setColor(Color.ORANGE);
            g.drawString("[F] FIRE READY", 400, 27);
        }
    }

    private void drawGameOver(Graphics2D g) {
        g.setColor(GAME_OVER_BG);// added by Alex
        g.fillRect(0,0,WIDTH,HEIGHT);// added by Alex
        drawGlowingText(g, "PLAYER WAS CREMATED BY OPPOSING XENOS", 70, WIDTH/2, HEIGHT/2 - 20, Color.RED);// Added by Alex
        // everything under this was done by AI
        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 30));
        drawCenteredString(g, "Score: " + score, WIDTH/2, HEIGHT/2 + 50);

        g.setFont(new Font("Arial", Font.PLAIN, 20));
        drawCenteredString(g, "Click to Restart", WIDTH/2, HEIGHT/2 + 100);
    }

    // --- UTILS ---
    private void drawGlowingText(Graphics2D g, String text, int size, int x, int y, Color c) {
        g.setFont(new Font("Arial", Font.BOLD, size));
        FontMetrics fm = g.getFontMetrics();
        int tx = x - fm.stringWidth(text)/2;

        g.setColor(new Color(c.getRed(), c.getGreen(), c.getBlue(), 50));
        g.drawString(text, tx+2, y+2); // Shadow
        g.setColor(c);
        g.drawString(text, tx, y);
    }

    private void drawButton(Graphics2D g, Rectangle r, String t, boolean active) {
        if(!active) {
            g.setColor(Color.DARK_GRAY);
            g.fill(r);
            g.setColor(Color.GRAY);
            g.draw(r);
            g.setColor(Color.GRAY);
            drawCenteredString(g, t, r.x + r.width/2, r.y + r.height/2 + 5);
            return;
        }

        GradientPaint gp = new GradientPaint(r.x, r.y, new Color(50,50,50), r.x, r.y+r.height, new Color(20,20,20));
        g.setPaint(gp);
        g.fill(r);
        g.setColor(Color.CYAN);
        g.draw(r);
        g.setColor(Color.WHITE);
        drawCenteredString(g, t, r.x + r.width/2, r.y + r.height/2 + 5);
    }

    private void drawCenteredString(Graphics g, String text, int x, int y) {
        int w = g.getFontMetrics().stringWidth(text);
        g.drawString(text, x - w/2, y);
    }

    // --- INPUT ---
    public void keyPressed(KeyEvent e) {
        int k = e.getKeyCode();
        if(k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT) left = true;
        if(k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) right = true;

        if(k == KeyEvent.VK_SPACE) {
            if(currentState == State.PLAYING) player.jump();
        }

        if(k == KeyEvent.VK_F) {
            if(currentState == State.PLAYING && player.hasFireFlower) player.shootFire();
        }
    }
    public void keyReleased(KeyEvent e) {
        int k = e.getKeyCode();
        if(k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT) left = false;
        if(k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) right = false;
    }
    public void keyTyped(KeyEvent e) {}

    public void mousePressed(MouseEvent e) {
        if(currentState == State.MENU) {
            if(btnFaction.contains(e.getPoint())) currentState = State.FACTION_SELECT;
            else if(btnPlay.contains(e.getPoint()) && selectedFaction != null) startGame();
        } else if(currentState == State.FACTION_SELECT) {
            for(int i=0; i<4; i++) {
                if(factionBtns[i].contains(e.getPoint())) selectedFaction = Faction.values()[i];
            }
            if(btnBack.contains(e.getPoint())) currentState = State.MENU;
        } else if(currentState == State.PLAYING) {
            player.attack();
        } else if (currentState == State.GAME_OVER) {
            currentState = State.MENU;
        }
    }
    public void mouseMoved(MouseEvent e) { mouseX = e.getX(); mouseY = e.getY(); }
    public void mouseDragged(MouseEvent e) { mouseX = e.getX(); mouseY = e.getY(); }
    public void mouseClicked(MouseEvent e) {}
    public void mouseReleased(MouseEvent e) {}
    public void mouseEntered(MouseEvent e) {}
    public void mouseExited(MouseEvent e) {}

    // ==========================================
    // INNER CLASSES (Entities & Logic)
    // ==========================================

    class Player{
        double x, y, velX, velY;
        int width = 30, height = 46;
        int hp, maxHp;
        Faction faction;
        boolean onGround = false;
        int jumpsLeft;
        int maxJumps;

        // Buff States
        boolean hasFireFlower = false;
        int damageMod = 0;
        double speedMod = 0;

        Player(int x, int y, Faction f) {
            this.x = x; this.y = y; this.faction = f;
            this.maxHp = 100;
            this.hp = maxHp;

            // Faction Stats
            this.maxJumps = (f == Faction.RAVENGUARD) ? 3 : 2;
        }

        void update() {
            // Horizontal
            double baseSpeed = 5 + speedMod;
            if(left) velX = -baseSpeed;
            else if(right) velX = baseSpeed;
            else velX *= 0.8; // Friction

            x += velX;
            handleCollisions(true);

            // Gravity
            velY += 0.6;
            y += velY;
            onGround = false;
            handleCollisions(false);

            // Bounds
            if(x < 0) x = 0;
            if(x > WIDTH - width) x = WIDTH - width;
            if(y > HEIGHT) hp = 0; // Void death
        }

        void jump() {
            if (jumpsLeft > 0) {
                velY = -12; // Jump force
                jumpsLeft--;
                createExplosion(x + width/2, y + height, 5, Color.WHITE); // Jump Dust
            }
        }

        void handleCollisions(boolean horizontal) {
            // Optimization: Create specific rectangle only when needed or use coords
            Rectangle pRect = new Rectangle((int)x, (int)y, width, height); 
            
            for(Platform p : platforms) {
                if(pRect.intersects(p)) {
                    if(horizontal) {
                        if(velX > 0) x = p.x - width;
                        else if(velX < 0) x = p.x + p.width;
                        velX = 0;
                    } else {
                        if(velY > 0) {
                            y = p.y - height;
                            velY = 0;
                            onGround = true;
                            jumpsLeft = maxJumps; // Reset Jumps
                        } else {
                            y = p.y + p.height;
                            velY = 0;
                        }
                    }
                }
            }
        }

        void attack() {
            if(faction == Faction.TYRANIDS) {
                // Melee Attack
                createExplosion(x + (mouseX > x ? 30 : -30), y + 20, 20, Color.MAGENTA); // Slash visual
                Rectangle meleeBox = new Rectangle((int)x - 40, (int)y, 110, height);
                for(Enemy e : enemies) {
                    if(meleeBox.intersects(e.getBounds())) {
                        e.takeDamage(10 + damageMod);
                        // Blood
                        particles.add(new Particle(e.x, e.y, Color.RED, 4));
                    }
                }
            } else {
                // Shoot
                int dmg = (faction == Faction.ULTRAMARINE) ? 4 : 2;
                projectiles.add(new Projectile(x+width/2, y+height/2, mouseX, mouseY, false, dmg + damageMod));
            }
        }

        void shootFire() {
            // Fireball: High damage, exploding
            projectiles.add(new Projectile(x+width/2, y+height/2, mouseX, mouseY, true, 8));
        }

        void takeDamage(int amount) {
            hp -= amount;
            if(hp < 0) hp = 0;
        }

        void applyBuff(BuffType type) {
            switch(type) {
                case HEAL: hp = Math.min(hp + 30, maxHp); addNotification("HEALED", Color.GREEN); break;
                case DAMAGE: damageMod += 2; addNotification("DAMAGE UP", Color.RED); break;
                case SPEED: speedMod += 2; addNotification("SPEED UP", Color.CYAN); break;
                case FIRE_FLOWER: hasFireFlower = true; addNotification("FIRE FLOWER ACQUIRED", Color.ORANGE); break;
            }
        }

        void draw(Graphics2D g) {
            // Miasma Visual
            if(faction == Faction.DEATHWATCH) {
                g.setColor(MIASMA_COLOR); // Optimized: Used constant
                g.fillOval((int)x - 50, (int)y - 50, width + 100, height + 100);
            }

            g.setColor(faction.color);
            g.fillRect((int)x, (int)y, width, height);

            // Eyes
            g.setColor(Color.RED);
            if(mouseX > x) g.fillRect((int)x+20, (int)y+10, 5, 5); // Look right
            else g.fillRect((int)x+5, (int)y+10, 5, 5); // Look left

            // Aim line
            if(faction != Faction.TYRANIDS) {
                g.setColor(new Color(255,255,255,50));
                g.drawLine((int)x+width/2, (int)y+height/2, mouseX, mouseY);
            }
        }

        Rectangle getBounds() { return new Rectangle((int)x, (int)y, width, height); }
    }

    class Enemy {
        double x, y, vx, vy;
        int width, height, hp;
        EnemyType type;
        Color color;
        boolean dead = false;

        Enemy(double x, double y, EnemyType t) {
            this.x = x; this.y = y; this.type = t;
            if(t == EnemyType.GRUNT) { width=30; height=30; hp=2; color=Color.RED; }
            else if(t == EnemyType.ELITE) { width=45; height=45; hp=5; color=Color.ORANGE; }
            else { width=80; height=80; hp=10; color=new Color(100, 0, 0); } // Boss
        }

        void update() {
            // AI: Move to player
            if(x < player.x) vx = (type == EnemyType.BOSS) ? 1.0 : 2.0;
            else vx = (type == EnemyType.BOSS) ? -1.0 : -2.0;

            x += vx;

            // Gravity
            vy += 0.5;
            y += vy;

            // Floor Collision
            for(Platform p : platforms) {
                Rectangle r = getBounds();
                if(r.intersects(p) && vy > 0) {
                    y = p.y - height;
                    vy = 0;
                    // Jump Logic
                    if(player.y < y && rand.nextInt(50) == 0) vy = -12;
                }
            }
        }

        void takeDamage(int dmg) {
            hp -= dmg;
            if(hp <= 0) dead = true;
        }

        void draw(Graphics2D g) {
            g.setColor(color);
            g.fillRect((int)x, (int)y, width, height);
            // Health bar
            g.setColor(Color.BLACK);
            g.drawRect((int)x, (int)y-10, width, 5);
            g.setColor(Color.GREEN);
            int barW = (int)((hp / (double)(type==EnemyType.BOSS?10:(type==EnemyType.ELITE?5:2))) * width);
            g.fillRect((int)x, (int)y-10, barW, 5);
        }

        Rectangle getBounds() { return new Rectangle((int)x, (int)y, width, height); }
    }

    class Projectile {
        double x, y, dx, dy;
        boolean isFireball;
        int damage;
        boolean remove = false;

        Projectile(double x, double y, int tx, int ty, boolean fire, int dmg) {
            this.x = x; this.y = y; this.isFireball = fire; this.damage = dmg;
            double angle = Math.atan2(ty - y, tx - x);
            double speed = fire ? 12 : 15;
            dx = Math.cos(angle) * speed;
            dy = Math.sin(angle) * speed;
        }

        void update() {
            x += dx;
            y += dy;

            if(x < 0 || x > WIDTH || y < 0 || y > HEIGHT) remove = true;

            // Collision with enemies
            for(Enemy e : enemies) {
                if(getBounds().intersects(e.getBounds())) {
                    e.takeDamage(damage);
                    remove = true;
                    // Hit Visual
                    createExplosion(x, y, isFireball ? 30 : 10, isFireball ? Color.ORANGE : Color.YELLOW);
                    break;
                }
            }
            // Collision with platforms
            for(Platform p : platforms) {
                if(getBounds().intersects(p)) {
                    remove = true;
                    createExplosion(x, y, 5, Color.GRAY);
                }
            }
        }

        void draw(Graphics2D g) {
            g.setColor(isFireball ? Color.ORANGE : Color.YELLOW);
            int s = isFireball ? 12 : 6;
            g.fillOval((int)x, (int)y, s, s);
        }

        Rectangle getBounds() { return new Rectangle((int)x, (int)y, isFireball?12:6, isFireball?12:6); }
    }

    class Particle {
        double x, y, vx, vy;
        Color c;
        float life = 1.0f;
        double size;

        Particle(double x, double y, Color c, double size) {
            this.x = x; this.y = y; this.c = c; this.size = size;
            this.vx = (rand.nextDouble() - 0.5) * 5;
            this.vy = (rand.nextDouble() - 0.5) * 5;
        }

        void update() {
            x += vx;
            y += vy;
            life -= 0.05f;
        }

        void draw(Graphics2D g) {
            if(life <= 0) return;
            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, life));
            g.setColor(c);
            g.fill(new Ellipse2D.Double(x, y, size, size));
            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));
        }
    }

    class Buff {
        int x, y;
        BuffType type;
        double floatOffset = 0;

        Buff(double x, double y) {
            this.x = (int)x; this.y = (int)y;
            type = BuffType.values()[rand.nextInt(BuffType.values().length)];
        }

        void update() {
            floatOffset += 0.1;
            // Simple physics
            boolean onPlat = false;
            for(Platform p : platforms) {
                if(new Rectangle(x, y, 20, 20).intersects(p)) { y = p.y - 20; onPlat = true; }
            }
            if(!onPlat) y += 2;
        }

        void draw(Graphics2D g) {
            Color c = Color.WHITE;
            String l = "?";
            switch(type) {
                case HEAL: c=Color.GREEN; l="H"; break;
                case DAMAGE: c=Color.RED; l="D"; break;
                case SPEED: c=Color.CYAN; l="S"; break;
                case FIRE_FLOWER: c=Color.ORANGE; l="F"; break;
            }
            int drawY = (int)(y + Math.sin(floatOffset)*3);
            g.setColor(c);
            g.fillRect(x, drawY, 20, 20);
            g.setColor(Color.WHITE);
            g.drawRect(x, drawY, 20, 20);
            g.drawString(l, x+6, drawY+15);
        }

        Rectangle getBounds() { return new Rectangle(x, y, 20, 20); }
    }

    class Star {
        double x, y, s;
        float alpha;
        Star() {
            x = rand.nextInt(WIDTH); y = rand.nextInt(HEIGHT);
            s = rand.nextDouble() * 2; alpha = rand.nextFloat();
        }
        void update() { alpha += (rand.nextDouble()-0.5)*0.1; if(alpha>1) alpha=1; if(alpha<0) alpha=0; }
        void draw(Graphics2D g) {
            g.setColor(new Color(1f, 1f, 1f, alpha));
            g.fill(new Ellipse2D.Double(x, y, s, s));
        }
    }

    class Platform extends Rectangle {
        Platform(int x, int y, int w, int h) { super(x, y, w, h); }
    }
    
    //Ms.Kim i found a better way to add a score
    //it is similar to the form we learned in class
    //it does use a try cand catch method
    
    private void codexScrollOfChaos() { 
    // made it simple for myself to understand
    //void because it does not return anything to the main code. 
    //made it private because so only this class uses it. runs when score needs to be saved.
  try{
        FileWriter scroll = new FileWriter("codex.txt", true);// learned that this makes it so that the code appended 
        //appended meaning that the code in the file isin't replaced and rather moved to the next line
       scroll.write("Score: " + score + "\n"); //this makes it so that the score is written line by line 
        scroll.close();// puts it into the file. learned that without it the info is either corrupted or lost
      }catch (IOException c){ 
              c.printStackTrace(); //this finds the problem and makes a trace of the problem 
         //does this by tracing the "sequence" of methods and finding the problem 
          //still need to figure out how to implement this properly
          //I think that i need to apply this to the death or hp 
      }
    
     }//also realisex that i should use .write so the score value is a string and not an int 
}
 

